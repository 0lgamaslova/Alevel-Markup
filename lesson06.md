# Лекция 6

# :triangular_flag_on_post: 1.Встроенные стили браузеров. CSS reset.

У каждого браузера есть свои встроенные стили HTML-документов, созданные для улучшения читабельности. Вы наверняка уже видели, как выглядит «голая» веб-страница в браузере: синие подчеркнутые ссылки, черный шрифт, полужирное начертание заголовков и т. д.

Каждый браузер имеет свои отличия во встроенных стилях: например, в IE нет отступа от верхнего края окна, а в Firefox есть. Таких отличий существует много. Чтобы они не создавали помех для кроссбраузерности при написании собственного стиля CSS, можно воспользоваться методом сброса встроенных стилей.

Инструмент для сброса стилей – это, по сути, та же самая таблица CSS, где описаны правила, которые сбрасывают встроенные стили браузеров, устанавливая базовые значения свойств. Называется такая таблица **reset.css** и служит для того, чтобы вы могли начать создавать стиль «с нуля». Вот пример стандартной таблицы сброса:

```
    html, body, div, span, applet, object, iframe,
    h1, h2, h3, h4, h5, h6, p, blockquote, pre,
    a, abbr, acronym, address, big, cite, code,
    del, dfn, em, img, ins, kbd, q, s, samp,
    small, strike, strong, sub, sup, tt, var,
    b, u, i, center,
    dl, dt, dd, ol, ul, li,
    fieldset, form, label, legend,
    table, caption, tbody, tfoot, thead, tr, th, td,
    article, aside, canvas, details, embed, 
    figure, figcaption, footer, header, hgroup, 
    menu, nav, output, ruby, section, summary,
    time, mark, audio, video {
    	margin: 0;
    	padding: 0;
    	border: 0;
    	font-size: 100%;
    	font: inherit;
    	vertical-align: baseline;
    }
    /* HTML5 display-role reset for older browsers */
    article, aside, details, figcaption, figure, 
    footer, header, hgroup, menu, nav, section {
    	display: block;
    }
    body {
    	line-height: 1;
    }
    ol, ul {
    	list-style: none;
    }
    blockquote, q {
    	quotes: none;
    }
    blockquote:before, blockquote:after,
    q:before, q:after {
    	content: '';
    	content: none;
    }
    table {
    	border-collapse: collapse;
    	border-spacing: 0;
    }
```


Этот вариант таблицы [Reset.css](http://meyerweb.com/eric/tools/css/reset/) разработал известный опытный специалист по стандартам HTML и CSS Эрик Мейер. Он работает в области веб-технологий с 1993 года и является автором многих книг по CSS.

Конечно же, существуют и другие вариации Reset CSS, например, более популярный сейчас [Normalize.css](https://necolas.github.io/normalize.css/), который, в отличие от Reset CSS, сохраняет много полезных стилей по умолчанию, а не стирает их начисто. Это удобно, поскольку избавляет от необходимости вновь объявлять стили для многих стандартных элементов.

Если требуется, вы и сами можете создать свой файл сброса стилей, исходя из ваших потребностей.


_А сейчас вкратце о том, **что делает таблица сброса стилей**:_

*   в первом селекторе собраны наиболее популярные теги, для которых удаляются все отступы, рамки и поля, а также назначается размер шрифта 100%;
*   второй групповой селектор предназначен для правильного отображения тегов HTML5 в старых браузерах;
*   с помощью свойства `line-height` селектора `body` устанавливается одинаковый интерлиньяж (межстрочный интервал) для текста;
*   для списков `ol`, `ul` убраны маркеры;
*   отменены кавычки и другой контент перед и после содержимого тегов `blockquote`, `q`;
*   упрощено добавление рамок для ячеек таблиц.

Файл сброса стилей необходимо подключать раньше, чем собственные стили. Если вы внимательно читали абзац о приоритетах, то уже поняли, почему `reset.css` должен находиться перед другими стилями: потому что правила, указанные ниже в коде, перезаписывают правила, объявленные ранее.

# :triangular_flag_on_post: 2.Блочная модель

![](https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-6-block.png)"width: 300px;"

**Область содержимого** — это содержимое элемента, например, текст или изображение.

**Внутренний отступ** задается свойством **_padding_**. Внутренний отступ — это расстояние между основным содержимым и его границей (рамкой). Если для элемента задать фон, то он распространится также и на поля элемента. Внутренний отступ не может принимать отрицательных значений, в отличие от внешнего отступа.

**Внешний отступ** задается свойством **_margin_**. Он добавляет расстояние снаружи элемента от внешней границы рамки до соседних элементов, тем самым разделяя элементы на странице. Внешние отступы всегда остаются прозрачными и через них виден фон родительского элемента.

Значения **_padding и margin задаются в следующем порядке_**: верхнее, правое, нижнее и левое.

**Граница**, или рамка элемента, задается с помощью свойства **_border_**. Если цвет рамки не задан, она принимает цвет основного содержимого элемента, например, текста. Если рамка имеет разрывы, то сквозь них будет проступать фон элемента.

Внешние, внутренние отступы и рамка элемента не являются обязательными, по умолчанию их значение равно нулю. Тем не менее, некоторые браузеры добавляют этим свойствам положительные значения по умолчанию на основе своих таблиц стилей. Очистить стили браузеров для всех элементов можно при помощи универсального селектора:


```
* {
    margin: 0;
    padding: 0;
}
```


```
Отступы задаются по ходу часовой стрелки, начиная сверху:

div {
    margin: 10px 0 20px 30px;
    padding: 10px 20px;
}
```


**Отрицательные отступы**

Отрицательные значения margin-top/margin-left смещают элемент со своего обычного места.

При сдвиге через margin соседние элементы занимают освободившееся пространство.

:exclamation: Отрицательных паддингов НЕ СУЩЕСТВУЕТ!

# :triangular_flag_on_post: 3. `border`

Граница, или рамка элемента, задается с помощью ствойства **_border_**

По умолчанию рамки всегда отрисовываются поверх фона элемента, фон распространяется до внешнего края элемента. 

Стиль **border** задается с помощью атрибутов:

*  border-style
*  border-width
*  border-color

```
или одной строкой:

border: [style] [width] [color];
```


## `border-style` - cтиль бордера

Стиль рамки определяет ее отображение, без этого свойства рамки не будут видны вообще. Для элемента можно задавать рамку для всех сторон одновременно с помощью свойства **border-style** или для каждой стороны отдельно с помощью уточняющих свойств **border-top-style, border-right-style, border-bottom-style, border-left-style** и т.д. 

Не наследуется.

![](https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-6-borderstyle.png)"width: 600px;"


## `border-width` - толщина границы

Задаёт толщину границы элемента.

Три переменные — thin (2 пикселя), medium (4 пикселя) и thick (6 пикселей) задают толщину границы. Для более точного значения толщину можно указывать в пикселях или других единицах.


@@@ (json)
[
    ["Число значений", "Результат"],
    ["1", "Толщина границы будет установлена для всех сторон элемента."],
    ["2", "Первое значение устанавливает толщину верхней и нижней границ, второе — левой и правой."],
    ["3", "Первое значение задаёт толщину верхней границы, второе — одновременно левой и правой границ, а третье — нижней границы."],
    ["4", "Поочерёдно устанавливается толщину верхней, правой, нижней и левой границ."]
]
@@@



## `border-color` - цвет бордера

С помощью этого свойства Вы можете задать цвет границы HTML элемента.

Цвет может быть задан следующими [способами](https://www.w3schools.com/colors/colors_names.asp):

1. С помощью имени (например 'red' задаст красный цвет);
2. С помощью RGB значения(например 'rgb(255,255,255)' задаст белый цвет);
3. С помощью шестнадцатеричного значения (например '#00ff00' задаст зеленый цвет).


Кроме того, можно задавать скругление уголков блока с помощью атрибута **border-radius**:

```
div {
    border-radius: 10px;
}
```

# :triangular_flag_on_post: 3. Box-sizing

Свойство  **_box-sizing_** используется для изменения блочной модели CSS применяемой по умолчанию, с помощью которой вычисляются ширина и высота элементов.
Свойство box-sizing может принимать одно из двух значений – border-box или content-box. В зависимости от выбранного значения браузер по-разному трактует значение свойств width/height.


**Значения box-sizing**

## `content-box`
Это значение по умолчанию. В этом случае свойства width/height обозначают то, что находится **_внутри padding_**.
```
body {
    box-sizing: content-box;
}
```

## `border-box`
Значения width/height задают высоту/ширину **_всего элемента_**.
```
body {
    box-sizing: border-box;
}
```

Для большей наглядности посмотрим на картинку этого div в зависимости от box-sizing:

![](https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-6-boxsizing.png)"widthL 200px;"


В верхнем случае браузер нарисовал весь элемент размером в width x height, в нижнем – интерпретировал `width/height` как размеры внутренней области.

Исторически сложилось так, что по умолчанию принят content-box, а border-box некоторые браузеры используют если не указан `DOCTYPE`, в режиме совместимости.

Но есть как минимум один случай, когда явное указание `border-box` может быть полезно: растягивание элемента до ширины родителя.


# :triangular_flag_on_post: 4. Свойство `display`
Свойство, которое определяет, как элемент должен быть показан в документе.


@@@ (json)
[
    ["display:", "comment"],
    ["inline", "инлайн (строчный)"],
    ["block", "блочный"],
    ["inline-block:", "инлайн-блочный"],
    ["table:", "таблица"],
    ["flex:", "флекс"],
    ["...", "..."],
    ["none", "-"]
]
@@@

Почему бы не использовать строчные элементы, такие как `<span>`?

Потому что **_вы выбираете элемент HTML по его смыслу, а не отображению_**. Если мы решили, что абзац подходит нашему содержимому лучше всего, мы не должны менять _тег ради стилизации_. Это CSS заботится о стилизации.

Короче говоря, **_display позволяет сменить тип элемента без изменения его смысла_**.

Для каждого варианта display есть определенное поведение:

## Блочные элементы

> **Блочным** называется элемент, который занимает всю доступную ширину и всегда начинается с новой строки. В HTML есть ряд элементов, у которых эти значения display установлены по умолчанию, поэтому они уже наделены свойствами блочных элементов. 


```
 Представители блочных элементов: 
 
    <address>           <figure>            <p>
    <article>           <footer>            <pre>
    <aside>             <form>              <section>
    <blockquote>        <h1>-<h6>           <table>
    <canvas>            <header>            <tfoot>
    <dd>                <hr>                <ul>
    <div>               <li>                 <ol>
    <dl>                <main>              <video>
    <dt>                <nav>               <figcaption>
    <fieldset>          <noscript>
```

**Особенности блочных элементов:**
1. По ширине блочные элементы занимают всё допустимое пространство.
2. Блок имеет параметры width, padding, border и margin.
3. Блоки располагаются по вертикали друг под другом.
4. На блочные элементы не действуют свойства, предназначенные для строчных элементов (например vertical-align)

Для превращения элемента в блочный элемент к селектору добавляется свойство display со значением block (+наследует все свойства блочного элемента).

```
.btn {
    display: block;
}
```

## Строчные элементы

> **Строчными** называются такие элементы, которые являются непосредственной частью строки, у них значение свойства [display](https://docs.google.com/document/d/1YZuJ1boKLqVtd1NTqVP9JdPS6ON3K8HpxvkBloKLwcM/edit#bookmark=kix.jv9n0txn7b19) установлено как inline. Вот они:

```
    <a>             <dfn>           <samp>
    <abbr>          <em>            <script>
    <acronym>       <i>             <small>
    <b>             <kbd>           <span>
    <bdo>           <label>         <strong>
    <big>           <map>           <sub>
    <br>            <object>        <sup>
    <cite>          <output>        <time>
    <code>          <q>             <var>
```

Элементы в основном они используются для изменения вида текста или его смыслового выделения.

Характерные **особенности строчных элементов:**

1. Свойства, связанные с размерами (width, height), не применимы: их размер связан с их содержимым
2. Размер элемента равен его содержимому плюс значения margin, border и padding. **_Заметьте одну особенность_** — для строчных элементов _margin_ работает только по горизонтали, но никак не вертикали. Таким образом, свойства margin-top и margin-bottom не действуют
3. Срочные элементы переносятся на другую строку при необходимости. 
4. Можно выравнивать по вертикали с помощью свойства vertical-align.
Свойство _vertical-align_ выравнивает элементы относительно друг друга по вертикали, что позволяет задавать выравнивание содержимого ячеек таблицы, задавать положение блоков и др.

## Строчно-блочные элементы

> **Строчно-блочные элементы** cочетают преимущества строчных и блочных элементов.  


```
    <img>
    <input>
    <button>
    <textarea>
    <select>
```


Характеристики этих элементов следующие:
1. Высота и ширина элемента вычисляется браузером автоматически, исходя из содержимого блока.
2. Размеры содержимого можно устанавливать через свойства width и height.
3. Ширина блока получается сложением значений margin-left, margin-right, width, border, и padding-left, padding-right.
4. Высота блока получается сложением значений height, margin-top, margin-bottom, border и padding-top, padding-bottom.
5. Несколько элементов идущих подряд располагаются на одной строке и переносятся на другую строку при необходимости.
6. Элементы можно выравнивать по вертикали с помощью свойства _vertical-align_.
7. Перенос текста в коде считается за пробел.

Строчно-блочный элемент можно определить, задав ему в стилях соответствующее свойство:

```
.btn {
    display: inline-block;   
}
```
 
# :triangular_flag_on_post: 5. Поток

Нормальный /базовый поток **_(normal flow)_**  - это способ, которым элементы страницы располагаются на веб-странице по умолчанию,

Элементы на веб-странице располагаются в нормальном потоке, если вы не применили к ним ни единого CSS для изменения их поведения.

По умолчанию содержимое элемента уровня блока (display: block) составляет 100% от ширины его родительского элемента и столь же высок, как и его содержимое. 

Даже без какого-либо применения CSS, **_HTML-документ уже содержит свои собственные правила_**:
*   **изменчивость**: как содержимое адаптируется к размерам браузера;
*   **очерёдность**: порядок, в котором появляются элементы;
*   **наложение**: как элементы появляются друг над другом.


## Изменчивость
Все блочные элементы являются **гибкими**. Они естественным образом адаптируют свою компоновку, чтобы приспособить внутреннее содержимое: относительно изменения количества внутреннего контента или ширині окна просмотра блоки имеют свойство менять свою высоту (height) и  ширину (width), толкая при этом последующие блоки.


## Очерёдность
Элементы HTML отображаются в том **порядке**, в котором они записаны **в коде**. Первый в коде — первый в браузере.

Каждый блок появляется в том порядке, в котором он появляется в коде HTML, **сверху вниз**.


## Наложение
У браузера есть **три измерения**.

Каждый элемент HTML принадлежит воображаемому **слою**.

**Порядок наложения** зависит от того, как элементы **вложены** друг в друга: дочерние элементы появляются **поверх** своих родителей.

*   Каждый **вложенный** элемент появляется _поверх_ своего родителя.
*   Чем **глубже** он по иерархии, тем _выше_ в наложении.


## Нарушение потока
Хотя поведение браузера по умолчанию является _эффективным_, этого бывает _недостаточно_ для нужд вашего дизайна.

Некоторые свойства CSS позволяют **нарушить** поток:
*   `height` и `width` могут поменять изменчивость элемента;
*   `float` нарушает поведение элемента, а также его окружения;
*   значения `absolute` и `fixed` у свойства `position` удаляют элемент из потока (изучим на следующем уроке);
*   `z-index` может менять порядок наложения элементов.


# :triangular_flag_on_post: 6. Свойство float:

Визуалка [тут](https://codepen.io/OlgaMaslova/pen/RvvXJK))


> В обычном порядке блочные элементы отображаются, начиная с верхнего края окна браузера по направлению к нижнему краю. Свойство **float** позволяет перемещать любой элемент, выравнивая его по левому или правому краю веб-страницы или содержащего его элемента-контейнера. При этом остальные блочные элементы будут его игнорировать, а строчные элементы будут смещаться вправо или влево, освобождая для него пространство и обтекая его

@@@ (json)
[
    ["float:", "comment"],
    ["none", "Значение по умолчанию. Также отменяет любое перемещение для элемента из группы элементов, для которых уже установлено обтекание."],
    ["left", "Элемент изымается из нормального потока элементов и позиционируется по левому краю блока-контейнера."],
    ["right", "Элемент позиционируется по правому краю блока-контейнера."]
]
@@@

**Очистка потока стилями при помощи класса `clearfix` и псевдокласса `:after` **

```
.clearfix:after { 
    content: ""; 
    display: table; 
    clear: both; 
}
```
Возьмем для примера код:


```
<div class="hero">
    <h2>Винни-Пух</h2>
    <div class="left">Картинка</div>
    <p>Текст.</p>
</div>
```

и стили для него:

```
.hero {
    background: #D2B48C;
    border: 1px solid red;
}

.left {
    float: left;
}
```

Из-за того, что блок с `float` удалён из потока, родитель не выделяет под него места (смотрим на картинку внизу)

![](https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/img-6-clearfix1.png)


> Элемент с `float` оказался выпавшим за границу родителя `.hero`.

===

**Чтобы этого не происходило, используют одну из следующих техник.**

**1) Поставить родителю float**

Элемент с `float` обязан расшириться, чтобы вместить вложенные `float-елементы`.

Поэтому, если это допустимо, то установка `float` контейнеру всё исправит:

```
.hero {
    background: #D2B48C;
    border: 1px solid red;
    float: left;
}
```

Разумеется, не всегда можно поставить родителю `float`, так что смотрим дальше.

**2) Добавить в родителя элемент с clear**

Добавим элемент `div style="clear:both` в самый конец контейнера `.hero`.

Он с одной стороны будет «нормальным» элементом, в потоке, и контейнер будет обязан выделить под него пространство, с другой – он знает о float и сместится вниз.

Соответственно, и контейнер вырастет в размере:

```
<div class="hero">
    <h2>Винни-Пух</h2>
    <div class="left">Картинка</div
    <p>Текст.</p>
    <div style="clear:both"></div>
</div>
```
Результат – правильное отображение, как и в примере выше. [Открыть код](https://plnkr.co/edit/j1k9832CTepfwU2T7Aeg?p=preview).

Единственный недостаток этого метода – лишний HTML-элемент в разметке.

**3) Универсальный класс clearfix**

Чтобы не добавлять в HTML-код лишний элемент, можно задать его через :after.

```
.clearfix:after { 
    content: " ";      /* добавить содержимое: "." */ 
    display: table;    /* сделать блоком, т.к. inline не может иметь clear */ 
    clear: both;       /* с обеих сторон clear */ 
}
```

Добавив этот класс к родителю, получим тот же результат, что и выше. [Открыть код](https://plnkr.co/edit/OjUQGiHHrIbmTlQMir4N?p=preview).

# :triangular_flag_on_post: 7. Свойство  overflow

**_Свойство overflow_** управляет тем, как ведёт себя содержимое блочного элемента, если его размер превышает допустимую длину/ширину.

Обычно блок увеличивается в размерах при добавлении в него элементов, заключая в себе всех потомков.

Но что, если высота/ширина указаны явно? Тогда блок не может увеличиться, и содержимое «переполняет» блок. Его отображение в этом случае задаётся свойством overflow.

**Возможные значения:**

*   visible (по умолчанию)
*   hidden
*   scroll
*   auto

Свойства `overflow-x/overflow-y` (или оба одновременно: `overflow`) задают поведение контейнера при переполнении:

@@@ (json)
[
    ["property:", "comment"],
    ["**visible**", "По умолчанию, содержимое вылезает за границы блока."],
    ["**hidden**", "Переполняющее содержимое невидимо."],
    ["**auto**", "Полоса прокрутки при переполнении"],
    ["**scroll**", "Полоса прокрутки всегда."]
]
@@@


Кроме того, значение `overflow: auto | hidden` изменяет поведение контейнера, содержащего `float'ы`. Так как элемент с `float` находится вне потока, то обычно контейнер не выделяет под него место. Но если стоит такой overflow, то место выделяется, т.е. контейнер растягивается. Более подробно этот вопрос рассмотрен в статье [Свойство "float".](https://docs.google.com/document/d/1wzBUUoaovEVxOZWpYMBfHIJ7NRMxmV7RfixOvbiT77g/edit#heading=h.g9iirymxxx6b)

Как ведут себя блоки можно посмотреть [тут](https://codepen.io/OlgaMaslova/pen/XQrdob?editors=1100)


# :house: HomeWork

**1.Первый уровень**

У вас есть следуюющий код:

```
    <span class="title">Title for element with "display:inline"</span>
```
Установить для этого элемента:

1) ширину 100px;

2) отступы к контенту : вверху - 5px, внизу - 15px, слева - 15px, справа - 10px

3) внешние отступы: вверху - 10px, внизу - 10px, слева - 15px, справа - 15px

---

**2.Второй уровень**

Создайте блок по образцу:

![](https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/hw-6.2.png)

**_Текст-рыба_** [тут](https://ru.lipsum.com/)

**_Картинки_** [тут](https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/hw-6.2.1.png) и [тут](https://github.com/olgamaslovaolga/Alevel-Markup/raw/master/images/hw-6.2.2.png)

---

**3.Третий уровень**

1) Примените свойства с первого задания ко второму.

2) Также не забудьте установить для документа **_box-sizing: border-box;_**

3) Дайте блоку бордер толщиной 5px зеленого цвета следующего стиля: сверху - цельная линия, по бокам - прерывистая.
